package uk.co.richtextformat.display{		import flash.display.MovieClip;	import flash.display.Sprite;	import flash.display.DisplayObject;	import flash.events.MouseEvent;	import flash.events.Event;	import org.richtextformat.interfaces.IEnable;		public class RolloverSprite extends Sprite implements IEnable 	{		public var id								:String;				protected var _mc							:Sprite;		protected var _rollover						:Sprite;		protected var _anim							:MovieClip;		protected var _dir							:int;		protected var _isPressed					:Boolean;				public static const OVER					:String = "rolloverSpriteOver";		public static const OUT						:String = "rolloverSpriteOut";		public static const PRESSED					:String = "rolloverSpritePressed";		public static const RELEASED				:String = "rolloverSpriteReleased";		public static const RELEASED_OUTSIDE		:String = "rolloverSpriteReleasedOutside";				// constructor		public function RolloverSprite (mc:Sprite)		{			_mc = mc;			_init();		}				private function _init ():void		{			addChild(_mc);						var obj:DisplayObject;			var mc:MovieClip;			var objName:String;			var i:int=-1;			var len:int = _mc.numChildren;			while (++i<len){				obj = _mc.getChildAt(i);				if (obj is MovieClip){					mc = obj as MovieClip;					switch (mc.totalFrames){						case 1:					_rollover = Sprite(mc);			break;						default:				_anim = MovieClip(mc);			break;					}				}			}						if (!_anim || !_rollover) throw new Error("RolloverSprite _init ERROR: either button or anim is undefined in RolloverSprite and class instance will therefore malfunction.");						_rollover.alpha = 0;			reset();		}				public function reset ():void		{			enable();		}				public function disable ():void		{			//trace("RolloverSprite disable: "+id);						_isPressed = false;						_rollover.removeEventListener(MouseEvent.MOUSE_OVER, _onRolloverOver);			_rollover.removeEventListener(MouseEvent.MOUSE_OUT, _onRolloverOut);			_rollover.removeEventListener(MouseEvent.MOUSE_DOWN, _onRolloverDown);			_rollover.removeEventListener(MouseEvent.MOUSE_UP, _onRolloverUp);						if (stage){				if ( stage.hasEventListener(MouseEvent.MOUSE_UP) ) stage.removeEventListener(MouseEvent.MOUSE_UP, _onRolloverUp);			}			if ( hasEventListener(Event.ENTER_FRAME) ) removeEventListener(Event.ENTER_FRAME, _animateSprite);						_anim.gotoAndStop(_anim.currentLabels[4].name);		}				public function enable ():void		{			//trace("RolloverSprite enable: "+id);						_rollover.addEventListener(MouseEvent.MOUSE_OVER, _onRolloverOver);			_rollover.addEventListener(MouseEvent.MOUSE_OUT, _onRolloverOut);			_rollover.addEventListener(MouseEvent.MOUSE_DOWN, _onRolloverDown);			_rollover.addEventListener(MouseEvent.MOUSE_UP, _onRolloverUp);						_anim.gotoAndStop(_anim.currentLabels[0].name);		}				protected function _onRolloverOut (e:MouseEvent):void		{			//trace("RolloverSprite _onRolloverOut "+id+" : "+_anim.currentFrame);			//if (!_isPressed){				if (_anim.currentLabel == _anim.currentLabels[3].name) _anim.gotoAndStop(_anim.currentLabels[2].name);				_dir = -1;				if ( !hasEventListener(Event.ENTER_FRAME) ) addEventListener(Event.ENTER_FRAME, _animateSprite)				_dispatchOut();			//}		}				protected function _onRolloverOver (e:MouseEvent):void		{			//trace("RolloverSprite _onRolloverOver "+id+" : "+_anim.currentFrame);			_dir = 1;			if ( !hasEventListener(Event.ENTER_FRAME) ) addEventListener(Event.ENTER_FRAME, _animateSprite)			_dispatchOver();		}				protected function _onRolloverDown (e:MouseEvent):void		{			//trace("RolloverSprite _onRolloverDown "+id+" : "+_anim.currentFrame);			_isPressed = true;			_anim.gotoAndStop(_anim.currentLabels[3].name);			stage.addEventListener(MouseEvent.MOUSE_UP, _onRolloverUp);			_dispatchPressed();		}				protected function _onRolloverUp (e:MouseEvent):void		{			//trace("RolloverSprite _onRolloverUp: ");			if (_isPressed){				_isPressed = false;				stage.removeEventListener(MouseEvent.MOUSE_UP, _onRolloverUp);								// this clause for release outside events				if (e.target!=_rollover && e.currentTarget!=_rollover){					//trace("RolloverSprite _onRolloverOut: release outside");					//_anim.gotoAndStop(_anim.currentLabels[2].name);					//_onRolloverOut(e);					_dispatchReleasedOutside();									// this clause for release inside/over events				} else {					//trace("RolloverSprite _onRolloverOut: release");					//_anim.gotoAndStop(_anim.currentLabels[2].name);					_dispatchReleased();				}			}		}				protected function _dispatchOver ():void		{			dispatchEvent(new Event(OVER));		}				protected function _dispatchOut ():void		{			dispatchEvent(new Event(OUT));		}				protected function _dispatchPressed ():void		{			dispatchEvent(new Event(PRESSED));		}				protected function _dispatchReleased ():void		{			dispatchEvent(new Event(RELEASED));		}				protected function _dispatchReleasedOutside ():void		{			dispatchEvent(new Event(RELEASED_OUTSIDE));		}				private function _animateSprite (e:Event):void		{			//trace("_animateSprite: "+_anim.currentFrame)			_anim.gotoAndStop(_anim.currentFrame + _dir);			if (_anim.currentLabel != _anim.currentLabels[1].name) removeEventListener(Event.ENTER_FRAME, _animateSprite);		}	}}